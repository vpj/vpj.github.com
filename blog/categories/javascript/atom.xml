<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | vpj's diary]]></title>
  <link href="http://vpj.github.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://vpj.github.com/"/>
  <updated>2013-10-02T20:10:12+05:30</updated>
  <id>http://vpj.github.com/</id>
  <author>
    <name><![CDATA[Varuna Jayasiri]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A few months with Coffeescript]]></title>
    <link href="http://vpj.github.com/blog/2013/02/01/a-few-months-with-coffeescript/"/>
    <updated>2013-02-01T21:42:00+05:30</updated>
    <id>http://vpj.github.com/blog/2013/02/01/a-few-months-with-coffeescript</id>
    <content type="html"><![CDATA[<p>We moved to <a href="http://coffeescript.org">coffeescript</a> about 3 months back and
Rewrote all the javascript code in coffescript in active projects.
So far things have been very smooth and we are really happy about the move.</p>

<p><span class='pullquote-right' data-pullquote='easy to learn.'>
Coffeescript is well documented and was quite easy to learn.
It only took a few hours to skim through the documentation and start coding.
Some features of coffeescript was not used at first because of our previous coding patterns.
</span></p>

<p><span class='pullquote-right' data-pullquote='more readable'>
Coffeescript is definitely more readable than javascript. Almost all operators are replaced with words.
Although this increases the length of the code, it becomes much easier to read.
</span></p>

<p>For example, <code>if, then, else</code> is used instead of conditional statements <code>?:</code>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Conditional statement  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">workingHours = </span><span class="k">if</span> <span class="nx">sunday</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">8</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<!--
Coffescript doesn't use semicolan and block expressions are delimeted by indentation.
Using `@property` instead of `this.property` improves readability while reducing the number of keystrokes.
-->


<p><span class='pullquote-right' data-pullquote='fewer lines code'>
Code written is coffeescript consists of fewer lines code, and sometimes fewer character in each line.
No curly brackets <code>{, }</code>, simpler function declarations, no variable declarations, etc.
are a few reasons for this. I believe coffeescript reduced the number of lines of our code by 15% to 40%.
</span></p>

<p>Also, Coffeescript has some cool features such as existence operator,
default values for function arguments, looping through arrays and objects, array slicing,
destructuring assignments, string interpolation, etc. to solve some of
the frequently occurring difficulties in javascript.</p>

<p>For instance, with string interpolation, instead of having to code
<code>"&lt;h1&gt;" + heading + "&lt;/h1&gt;&lt;p&gt;" + description + "&lt;/p&gt;</code>,
you could just write <code>"&lt;h1&gt;#{heading}&lt;/h1&gt;&lt;p&gt;#{description}&lt;/p&gt;"</code>.</p>

<h2>One language to rule them all</h2>

<p>We are using <a href="https://github.com/gradus/coffeecup">coffeecup</a> instead of HTML. So this takes of the need to maintain templates separately,
with different template engines for backend and frontend. Coffeecup templates are stored
in separate coffeescript files which are used by both the browser code (frontend)
and node js (backend) - we need backend rendering for indexing bots. And you can avoid repetitive
HTML sections by implementing helpers which can be reused.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nearby.lk Technology Stack]]></title>
    <link href="http://vpj.github.com/blog/2012/09/02/nearby-dot-lk-technology-stack/"/>
    <updated>2012-09-02T11:02:00+05:30</updated>
    <id>http://vpj.github.com/blog/2012/09/02/nearby-dot-lk-technology-stack</id>
    <content type="html"><![CDATA[<p><a href="http://nearby.lk">nearby.lk</a> is business search engine, currently operating only within Sri Lanka.
It has been growing rapidly in-terms of visitors, business listings as well as features and performance of the system, since the launch in February 2012.</p>

<h2>Server</h2>

<p><a href="http://nearby.lk">nearby.lk</a> runs on <strong>Google App Engine (GAE)</strong>. It was pretty easy to get things started on GAE - no need to setup servers, databases, etc. This was the main reason for picking GAE at first. We wanted something up and running as soon as possible. However, sometimes you feel like you dont have enough customizability.</p>

<p>App Engine gives a lot of services such as Google authentication, datastore, memcache, load balancing, image manipulation, a search API, email, relatime channels, xmpp, backends, etc. GAE documentation is also pretty good.</p>

<p>We started using Google authentication and Facebook authentication and later decided to drop google authentication as not many users were using that. We continue to use google authentication for admin section.</p>

<p>Load balancing seems to be a bit over doing, which causes new instances to be created unecessarily sometimes. In our app, this actually causes some low response times, becuase our program has a slow startup. Startup times were reduced significantly by caching all precomputations in memcache, which is common to all instances.</p>

<p>Images API was quite handy for image resizing. We also used search API for some parts of the search since recently.</p>

<p>GAE backends are quite useful for apps like ours where there is a lot of centralised processing (seaching). We will probably use it in the near future.</p>

<h2>Client</h2>

<p>We use <strong>jQuery</strong> for DOM manipulation, <strong>backbone.js</strong> for model-view architecture, and <strong>underscore.js</strong> for rendering with templates.</p>

<p>Backbone.js helps a lot to keep the javascript clean and structured. We also use backbone.js router for ajax navigation, which is pretty neat since it falls back to hash links if history API is not available.</p>

<p>Templating with underscore.js was quite handy, but we faced a small problem as backend rendering was done with django templates - we had to maintain two sets of templates. We are planning to use mustache templates, which is supported by underscore.js and has python implementations.</p>

<p><strong>Twitter Bootstrap</strong>, default theme with a bunch of customizations, is used in the web version and <strong>jQuery Mobile</strong> is used for mobile version of the app. We launched the mobile version recently and it still has some small glitches with the jQuery Mobile implementation. We used responsive features of Bootstrap with some tweaks because the mobile specific version was introduced.</p>
]]></content>
  </entry>
  
</feed>
